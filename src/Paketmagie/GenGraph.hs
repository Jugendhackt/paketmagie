module Paketmagie.GenGraph (randomGraph) where

import System.Random
import Paketmagie.Graph
import System.Environment (getArgs)
import Debug.Trace


getRandomString :: (RandomGen a) => a -> Int -> String
getRandomString _ 0 = []
getRandomString g n = do
    let (g1, g2) = split $ g
    (++) (take 1 . randomRs ('a', 'z') $ g1) (getRandomString g2 (n-1))


-- | a Random number generator and how many elements the List should contain
genNodes :: (RandomGen a) => a -> Int -> [Node]
genNodes _ 0 = []
genNodes g n = do
    let (g1, g2) = split $ g
    (:) (getRandomString g1 12) (genNodes g2 (n-1))


-- | returns a generated list of num edges generated by the g and [Node]
-- n has to be 0 since it is an internally used recursive state value
genEdges :: (RandomGen a) => a -> Int -> [Node] -> [Edge]
genEdges g n nodes
    | n == length nodes - 1 = []
    | nodes == [] = []
    | otherwise =
    let (g1, g2) = split $ g
        [n1, n2, n3] = take 3 . randomRs (0, length nodes - 1) $ g1
        node = nodes !! n
        ticksNum = 30
        edge1 = Edge node (nodes !! n1) (genProbs g ticksNum)
        edge2 = Edge node (nodes !! n2) (genProbs g1 ticksNum)
        edge3 = Edge node (nodes !! n3) (genProbs g2 ticksNum)
    in edge1:edge2:edge3:(genEdges g2 (n+1) nodes)



-- | returns a list of doubles of length n generated with g
genProbs :: (RandomGen a) => a -> Int -> [Double]
genProbs _ 0 = []
genProbs g n = do
    let (g1, g2) = split $ g
    (:) (fst . randomR (0.5, 1.0) $ g1) (genProbs g2 (n-1))


-- | returns a random Graph of length n
randomGraph :: Int -> IO TickingGraph
randomGraph n = do
    g <- newStdGen
    let nodeList = genNodes g n
        edgeList = genEdges g 0 nodeList
    return . TickingGraph (removeDuplicateEdges edgeList) $ 0


-- | removes duplicate or self-referential edges
removeDuplicateEdges :: [Edge] -> [Edge]
removeDuplicateEdges [] = []
removeDuplicateEdges (x:xs) | selfReferential x = removeDuplicateEdges xs
removeDuplicateEdges (x:xs) =
    x:(removeDuplicateEdges (filter (not . isDroppable x) xs ) )


-- | Triple-matching the edges for duplicates
matchTriple :: [Edge] -> [Edge]
matchTriple [] = []
matchTriple (a:b:c:xs) = let ys = [a, b, c]
                in removeDuplicateEdges ys ++ matchTriple xs


-- | returns if an Edge is droppable based on if it's a duplicate
isDroppable :: Edge -> Edge -> Bool
isDroppable (Edge from1 to1 _) (Edge from2 to2 _) =
    ((from1 == from2) && (to1 == to2) )


-- | returns if an Edge is self-referential
selfReferential :: Edge -> Bool
selfReferential (Edge from to _) = from == to
